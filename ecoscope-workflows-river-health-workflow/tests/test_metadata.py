# AUTOGENERATED BY ECOSCOPE-WORKFLOWS; see fingerprint in README.md for details

from typing import get_args
from unittest.mock import patch

import pydantic
import pytest
from ecoscope_workflows_river_health_workflow.formdata import FormData
from ecoscope_workflows_river_health_workflow.params import Params
from ecoscope_workflows_runner.app import app
from ecoscope_workflows_runner.testing import Case
from fastapi.testclient import TestClient


@pytest.fixture
def client(matchspec_override: str):
    with patch.dict(
        "os.environ",
        {"ECOSCOPE_WORKFLOWS_MATCHSPEC_OVERRIDE": matchspec_override},
    ):
        with TestClient(app) as client:
            yield client


@pytest.fixture(scope="session")
def formdata(success_case: Case) -> dict:
    """From a flat set of paramaters, create nested representation to reflect how the RJSF
    formdata would be structured. This is used for testing the formdata validation endpoint,
    and allows us to test the formdata validation endpoint without having to manually create
    the nested structure.
    """
    formdata: dict[str, dict] = {}
    aliased_annotations = {
        v.alias: v.annotation for v in FormData.model_fields.values() if v.alias
    }
    task_groups = {
        k: list(get_args(v)[0].model_fields) for k, v in aliased_annotations.items()
    }
    for k, v in success_case.params.items():
        if k in FormData.model_fields:
            formdata[k] = v
        else:
            group = next(g for g in task_groups if k in task_groups[g])
            if group in formdata:
                formdata[group].update({k: v})
            else:
                formdata[group] = {k: v}
    return formdata


def test_get_params(client: TestClient):
    response = client.get("/rjsf")
    assert response.status_code == 200
    assert set(list(response.json())) == {
        "properties",
        "$defs",
        "additionalProperties",
        "uiSchema",
    }


def test_get_data_connection_property_names(client: TestClient):
    response = client.get("/data-connection-property-names")
    assert response.status_code == 200
    response_json = response.json()
    assert isinstance(response_json, dict)
    assert all(
        isinstance(k, str) and isinstance(v, list) for k, v in response_json.items()
    )


def test_validate_formdata(client: TestClient, success_case: Case, formdata: dict):
    invalid_request = client.post("/formdata-to-params", json={"invalid": "request"})
    assert invalid_request.status_code == 422

    response = client.post("/formdata-to-params", json=formdata)
    assert response.status_code == 200

    assert set(success_case.params).issubset(set(response.json()))

    if set(formdata) != set(success_case.params):
        # this workflow uses task groups, so make one other assert
        # task groups are not required, so these asserts are skipped
        # for workflows that simply use a flat layout

        with pytest.raises(pydantic.ValidationError):
            Params(**formdata)

    assert Params(**response.json()) == Params(**success_case.params)


def test_generate_nested_params(client: TestClient, success_case: Case, formdata: dict):
    response = client.post("/params-to-formdata", json=success_case.params)
    assert response.status_code == 200

    assert FormData(**response.json()) == FormData(**formdata)


def test_round_trip(client: TestClient, success_case: Case, formdata: dict):
    generate_params_response = client.post(
        "/params-to-formdata", json=success_case.params
    )
    assert generate_params_response.status_code == 200
    assert generate_params_response.json() == formdata

    validate_response = client.post(
        "/formdata-to-params", json=generate_params_response.json()
    )
    assert validate_response.status_code == 200

    assert set(validate_response.json()) == set(success_case.params)
    assert Params(**validate_response.json()) == Params(**success_case.params)
